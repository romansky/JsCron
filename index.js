// Generated by CoffeeScript 1.8.0
(function() {
  var jscron, logr,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  logr = require('node-logr').getLogger("JsCron");

  exports.jscron = jscron = (function() {
    function jscron() {}


    /**
    	Cron Format
    	-----------
    	*	*	*	*	*	*
    	|	|	|	|	|	|day of week(0-6)
    	|	|	|	|	|month(1-12)
    	|	|	|	|day of month(1-31)
    	|	|	|hour(0-23)
    	|	|minute(0-59)
    	|seconds(0-59)
    
    	*	- all the options for that field
    	* /2- starting from the first option, every other option
    	0	- only use the explicitly provided option
    	2,4 - use list of values provided, separated by comma
     */

    jscron.parse = function(cron, startTimeUnix, endTimeUnix) {
      var cronTimes, day, days, daysDiff, daysSinceEpoch, dows, endTimeDate, getNextDay, hour, hours, isEndDay, isEndHour, isEndMinute, isStartDay, isStartHour, isStartMinute, lastDay, minute, minutes, months, second, seconds, startTimeDate, zDay, zDayHours, zDayMinutes, zDaySeconds, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
      if (startTimeUnix > endTimeUnix) {
        logr.error("Start time is ahead of end time!");
        return [];
      }

      /** first find the minimal time step */
      cronTimes = [];
      day = 24 * 60 * 60 * 1000;
      daysDiff = Math.round(Math.abs((endTimeUnix - startTimeUnix) / day));
      startTimeDate = new Date(startTimeUnix);
      endTimeDate = new Date(endTimeUnix);
      _ref = this._findOptions(cron), seconds = _ref[0], minutes = _ref[1], hours = _ref[2], days = _ref[3], months = _ref[4], dows = _ref[5];
      zDay = null;
      daysSinceEpoch = function(date) {
        return Math.floor(date.getTime() / day);
      };
      lastDay = daysSinceEpoch(endTimeDate);
      getNextDay = function(refDate) {
        if (!refDate) {
          return startTimeDate;
        } else {
          return new Date(refDate.getTime() + day);
        }
      };
      while (daysSinceEpoch(zDay = getNextDay(zDay)) <= lastDay) {
        if (_ref1 = zDay.getUTCDate(), __indexOf.call(days, _ref1) < 0) {
          continue;
        }
        if (_ref2 = zDay.getUTCMonth() + 1, __indexOf.call(months, _ref2) < 0) {
          continue;
        }
        if (_ref3 = zDay.getUTCDay(), __indexOf.call(dows, _ref3) < 0) {
          continue;
        }
        isStartDay = daysSinceEpoch(zDay) === daysSinceEpoch(startTimeDate);
        isEndDay = daysSinceEpoch(zDay) === daysSinceEpoch(endTimeDate);
        zDayHours = hours;
        if (isStartDay) {
          zDayHours = zDayHours.filter(function(h) {
            return h >= startTimeDate.getUTCHours();
          });
        }
        if (isEndDay) {
          zDayHours = zDayHours.filter(function(h) {
            return h <= endTimeDate.getUTCHours();
          });
        }
        for (_i = 0, _len = zDayHours.length; _i < _len; _i++) {
          hour = zDayHours[_i];
          isStartHour = isStartDay && hour === startTimeDate.getUTCHours();
          isEndHour = isEndDay && hour === endTimeDate.getUTCHours();
          zDayMinutes = minutes;
          if (isStartHour) {
            zDayMinutes = zDayMinutes.filter(function(m) {
              return m >= startTimeDate.getUTCMinutes();
            });
          }
          if (isEndHour) {
            zDayMinutes = zDayMinutes.filter(function(m) {
              return m <= endTimeDate.getUTCMinutes();
            });
          }
          for (_j = 0, _len1 = zDayMinutes.length; _j < _len1; _j++) {
            minute = zDayMinutes[_j];
            isStartMinute = isStartHour && minute === startTimeDate.getUTCMinutes();
            isEndMinute = isEndHour && minute === endTimeDate.getUTCMinutes();
            zDaySeconds = seconds;
            if (isStartMinute) {
              zDaySeconds = zDaySeconds.filter(function(s) {
                return s >= startTimeDate.getUTCSeconds();
              });
            }
            if (isEndMinute) {
              zDaySeconds = zDaySeconds.filter(function(s) {
                return s < endTimeDate.getUTCSeconds();
              });
            }
            for (_k = 0, _len2 = zDaySeconds.length; _k < _len2; _k++) {
              second = zDaySeconds[_k];
              cronTimes.push(Date.UTC(zDay.getUTCFullYear(), zDay.getUTCMonth(), zDay.getUTCDate(), hour, minute, second));
            }
          }
        }
      }
      return cronTimes;
    };

    jscron.timeToCron = function(time) {
      var date;
      date = new Date(time);
      return "" + (date.getUTCSeconds()) + " " + (date.getUTCMinutes()) + " " + (date.getUTCHours()) + " " + (date.getUTCDate()) + " " + (date.getUTCMonth() + 1) + " *";
    };

    jscron._findOptions = function(cron) {
      var allowedNum, dayOfMonth, dayOfWeek, finish, hours, minutes, month, p, param, range, rangeRes, res, seconds, start, step, values, x, _i, _j, _k, _l, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _results, _results1, _results2;
      if (cron.split(" ").length < 6) {
        return null;
      }
      seconds = cron[0], minutes = cron[1], hours = cron[2], dayOfMonth = cron[3], month = cron[4], dayOfWeek = cron[5];
      allowedNum = [[0, 59], [0, 59], [0, 23], [1, 31], [1, 12], [0, 6]];
      res = [];
      _ref = cron.split(" ");
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        param = _ref[_i];
        if (!/^[0-9]*$/.test(param)) {
          if (param === "*") {
            res.push((function() {
              _results = [];
              for (var _j = _ref1 = allowedNum[res.length][0], _ref2 = allowedNum[res.length][1]; _ref1 <= _ref2 ? _j <= _ref2 : _j >= _ref2; _ref1 <= _ref2 ? _j++ : _j--){ _results.push(_j); }
              return _results;
            }).apply(this));
          } else if (/^[0-9\*\-]*\/*[0-9\*]*$/.test(param)) {
            _ref3 = param.split("/"), range = _ref3[0], step = _ref3[1];
            step = parseInt(step);
            if (range === "*") {
              range = (function() {
                _results1 = [];
                for (var _k = _ref4 = allowedNum[res.length][0], _ref5 = allowedNum[res.length][1]; _ref4 <= _ref5 ? _k <= _ref5 : _k >= _ref5; _ref4 <= _ref5 ? _k++ : _k--){ _results1.push(_k); }
                return _results1;
              }).apply(this);
            } else if (/^[0-9]*-[0-9]*$/.test(range)) {
              start = parseInt(range.split("-")[0]);
              finish = parseInt(range.split("-")[1]);
              range = (function() {
                _results2 = [];
                for (var _l = start; start <= finish ? _l <= finish : _l >= finish; start <= finish ? _l++ : _l--){ _results2.push(_l); }
                return _results2;
              }).apply(this);
            }
            rangeRes = (function() {
              var _len1, _m, _results3;
              _results3 = [];
              for ((step > 0 ? (_m = 0, _len1 = range.length) : _m = range.length - 1); step > 0 ? _m < _len1 : _m >= 0; _m += step) {
                x = range[_m];
                _results3.push(x);
              }
              return _results3;
            })();
            res.push(rangeRes);
          } else if (/^[0-9\,]*/.test(param)) {
            values = (function() {
              var _len1, _m, _ref6, _results3;
              _ref6 = param.split(",");
              _results3 = [];
              for (_m = 0, _len1 = _ref6.length; _m < _len1; _m++) {
                x = _ref6[_m];
                _results3.push(parseInt(x));
              }
              return _results3;
            })();
            res.push(values);
          }
        } else {
          p = parseInt(param);
          if (p >= allowedNum[res.length][0] && p <= allowedNum[res.length][1]) {
            res.push([p]);
          }
        }
      }
      return res;
    };

    return jscron;

  })();

}).call(this);
